- [結局、Go 言語をやめる理由はなかった件 - Qiita](https://qiita.com/Maki-Daisuke/items/23c1285500208048de80)
- [イベントループなしでのハイパフォーマンス – C10K 問題への Go の回答](https://postd.cc/performance-without-the-event-loop/)

> C10K 問題への Go の回答
> Go においては通常、syscall はブロッキングなオペレーションで、ファイル記述子の読み込みと書き込みを含んでいます。Go のスケジューラは元のスレッドがブロックされても、未使用のスレッドを探したり生成したりすることにより Go ルーチンを提供し続けます。ブロックされたスレッドが少ないとすぐにローカル I/O のバンド幅を使い果たしてしまうため、実際、ファイル I/O にとっては問題なく機能します。
> しかしネットワークソケットでは、常に Go ルーチンのほぼ全てがネットワーク I/O を待って意図的にブロックされてしまいます。ネイティブな実装では、ネットワークトラフィックを待ちブロックされてしまうため、Go ルーチンと同じ数だけのスレッドを必要とします。Go の統合されたネットワークポーリング機能は、ランタイムとネットワークパッケージとの協力により、これを効果的に処理します。
> Go の古いバージョンでは、1 つの Go ルーチンが kqueu や epoll を使って準備完了通知をチェックしポーリングを行っていました。このポーリング用 Go ルーチンはチャネルを通じて、待機中の Go ルーチンへと通知していました。これにより、syscall 毎のスレッドというオーバーヘッドを避けることができ、チャネルが送信する汎用のウェイクアップの仕組みを使っていました。スケジューラはウェイクアップのソースや重要性については全く認識していなかったということです。
> 最新の Go では、ネットワークポーリング機能はランタイムに統合されています。どの Go ルーチンがソケットの準備完了を待っているかをランタイムが把握しているため、パケットが到着し次第すぐに同じ CPU へと Go ルーチンを配置することができ、遅延を減らし、スループットが向上します。
> 結論として、Go ルーチンが提供する強力な抽象化により、プログラマはスレッドプールやイベントループについての心配から解放されます。
> Go ルーチンのスタックは、スレッドスタックやスレッドプールのサイズを気にすることなく、必要なだけ大きくすることができます。
> 統合されたネットワーク調査により、Go のプログラマは、複雑なコールバック方式を避け、OS が提供する最も効率的な I/O 完了のロジックを利用できるのです。
> ランタイムにより、Go ルーチンを全て供給するのに十分なスレッドと、コアを使用可能にしておくことが保証されます。
> そして、Go のプログラマはそういった全ての機能を意識しなくていいのです。
