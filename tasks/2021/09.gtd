2021-09-30

o pallet token
o research IEO, NFT, PLT from coinchecka articles.

// hyperapp + esbuild + css module で最小構成でフロントエンドを作成するが、特にレスポンスデータの型付が出来ない事、
// 型推論が効かないので大きくすると訳分からなくなるのでTypescriptも導入しようと思ったが、
// Elmをまず検討して見ることにした。architecture が確立されてないと手を出したくない。
// https://guide.elm-lang.org/architecture/


// func TestGetTodo(t *testing.T) {
// 	t.Run("test root handler", func(t *testing.T) {
// 		rr := httptest.NewRecorder()
// 		req, err := http.NewRequest("GET", "/", nil)
// 		if err != nil {
// 			t.Fatal(err)
// 		}
// 		g.ServeHTTP(rr, req)
// 		if status := rr.Code; status != http.StatusOK {
// 			t.Errorf("handler returned wrong status code: got %v want %v",
// 				status, http.StatusOK)
// 		}
// 	})
// }

resource "aws_ecr_repository" "lambda_containter" {
  name = "lambda-s3-image-upload"
}

# Comment out after making ECR and IAM.
resource "aws_lambda_function" "lambda_container" {
  function_name = "lambda-s3-image-upload"
  role          = aws_iam_role.lambda_container.arn
  package_type  = "Image"
  image_uri     = "${aws_ecr_repository.lambda_containter.repository_url}:v1"
  timeout       = 60

  lifecycle {
    ignore_changes = [image_uri]
  }
}

func HandlerBasic(req events.APIGatewayProxyRequest) (Response, error) {
	var res Response
	var buf bytes.Buffer
	var img Request
	if err := json.Unmarshal([]byte(req.Body), img); err != nil {
		res = Response{
			StatusCode:      400,
			IsBase64Encoded: false,
			Body:            req.Body,
			Headers: map[string]string{
				"Content-Type": "application/json",
			},
		}
		return res, nil
	}
	log.Println(req.Body)
	log.Println(req.IsBase64Encoded)
	res = Response{
		StatusCode:      200,
		IsBase64Encoded: false,
		Body:            buf.String(),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}
	return res, nil
}


https://github.com/ssb-ngi-pointer/go-ssb-room


{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Action": ["s3:GetObject", "s3:PutObject"],
      "Effect": "Allow",
      "Principal": "*",
      "Resource": [
        "arn:aws:s3:::/*"
      ]
    }
  ]
}


{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "WriteObjectActions",
      "Effect": "Allow",
      "Principal": "*",
      "Action": [
        "s3:AbortMultipartUpload",
        "s3:GetObject",
        "s3:ListBucket",
        "s3:ListBucketMultipartUploads",
        "s3:PutObject"
      ],
      "Resource": "arn:aws:s3:::"
    }
  ]
}


値をv,eに入れる方法 、reduceの仕様に関しては、
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce を見てください。
コードも追記したので確認してください。

https://teratail.com/questions/349562
// docker-compose run api sh && go generate .
//go:generate go install github.com/volatiletech/sqlboiler/v4@latest
//go:generate go install github.com/volatiletech/sqlboiler/v4/drivers/sqlboiler-psql@latest
//go:generate sqlboiler --config sqlboiler.toml psql

curl -H "Content-Type: image/png" --data-binary "@test.png" -X POST https://XXXXX.execute-api.ap-northeast-1.amazonaws.com/test/myresource

言語やOSによってはプログラムの実行時に特定のソフトウェア部品が必要な場合があり、これを「ランタイムライブラリ」（runtime library）「ランタイムパッケージ」（runtime package）「ランタイムエンジン」（runtime engine）「ランタイムモジュール」（runtime module）などと言うが、これらを略してランタイムと呼ぶ場合がある。

const getAllFiles = (dir, filePaths = []) => {
  fs.readdirSync(dir).forEach((file) => {
    const filepath = path.join(dir, file);
    if (fs.statSync(filepath).isDirectory()) {
      filePaths = getAllFiles();
    } else {
      filePaths.push(filepath);
    }
  });
  return filePaths;
};

Worn-Off-Keys-Cognito-Tutorials/
https://github.com/gin-contrib/cors

[Serverless Framework Documentation](https://www.serverless.com/framework/docs/)

[GitHub - chrisxue815/realworld-aws-lambda-dynamodb-go: Medium.com clone (called Conduit) built with AWS Lambda, DynamoDB, Go and Serverless](https://github.com/chrisxue815/realworld-aws-lambda-dynamodb-go)

//go:generate go install github.com/volatiletech/sqlboiler/v4@latest
//go:generate go install github.com/volatiletech/sqlboiler/v4/drivers/sqlboiler-psql@latest
//go:generate sqlboiler --config sqlboiler.toml psql

func passwordEncrypt(password string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(hash), err
}

func compareHashAndPassword(hash, password string) error {
	return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
}


func add(c *gin.Context) {
	client := db.Connect()
	user := client.User.Create()
	user.SetFirstName("first")
	user.SetLastName("last")
	user.SetCompanyID(1)
	if _, err := user.Save(context.Background()); err != nil {
		log.Println(err.Error())
	}
	c.String(http.StatusOK, "message hello")
}

func test(c *gin.Context) {
	client := db.Connect()
	ctx := context.Background()
	items, err := client.User.Query().All(ctx)
	if err != nil {
		log.Fatalf("failed querying todos: %v", err)
	}
	var res string
	log.Println(items)
	for _, t := range items {
		log.Println(t.ID, t)
		res = res + t.FirstName
	}
	// db.User.Get()
	c.String(http.StatusOK, "message hello"+res)
}



I'm not sure if hyperway's performance is optimal, but I like the interface.

// func dbMigrate() {
// 	dbname := os.Getenv("POSTGRES_DB")
// 	dbuser := os.Getenv("POSTGRES_USER")
// 	dbpass := os.Getenv("POSTGRES_PASSWORD")
// 	dbhost := os.Getenv("POSTGRES_HOST")
// 	dbport := os.Getenv("POSTGRES_PORT")

// 	client, err := ent.Open("postgres", fmt.Sprintf("host=%s port=%s user=%s dbname=%s password=%s sslmode=disable",
// 		dbhost, dbport, dbuser, dbname, dbpass))
// 	if err != nil {
// 		log.Fatalf("failed opening connection to postgres: %v", err)
// 	}
// 	defer client.Close()
// 	ctx := context.Background()
// 	if err := client.Schema.WriteTo(ctx, os.Stdout, migrate.WithForeignKeys(false)); err != nil {
// 		log.Fatalf("failed printing schema changes: %v", err)
// 	}
// }


      MYSQL_ROOT_PASSWORD: pass 
      MYSQL_DATABASE: auth_server
      MYSQL_USER: 
      MYSQL_PASSWORD: 1234567890


DROP TABLE IF EXISTS users;

CREATE TABLE users (
  id integer AUTO_INCREMENT,
  name varchar(255),
  mail varchar(255),
  password varchar(255),
  primary key(id)
);

INSERT INTO users (name, mail, password)
VALUES
  ('', 'test1@mail.com', 'pass1'),
  ('taro', 'test2@mail.com', 'pass2');
