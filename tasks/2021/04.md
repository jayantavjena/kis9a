# After.read<!--{{{-->

[Case Study: Grep Operator, Part One / Learn Vimscript the Hard Way](https://learnvimscriptthehardway.stevelosh.com/chapters/32.html)

[Qiita レジェンド達の偉大さをシェル芸で眺めて 2016 年を振り返る - Qiita](https://qiita.com/t_nakayama0714/items/776724410b2a119af088)

[達人プログラマーまとめ - Qiita](https://qiita.com/m-hatano/items/872c26106240e0e21e0f)

[シェルの変数展開 - Qiita](https://qiita.com/bsdhack/items/597eb7daee4a8b3276ba)

[シェルスクリプトを自己文章化する - Qiita](https://qiita.com/suttang/items/d4b4474e93c8e74ae515)

[シェルスクリプトを使って「これから毎日金相場をスクレイピングしようぜ？」という話 - Qiita](https://qiita.com/furandon_pig/items/80562f6adcce53baeb0a)

[POSIX 原理主義に基づく究極のスクレイピング - Qiita](https://qiita.com/richmikan@github/items/024b1f3869c84b9a3a21)

[環境に依存しないワンライナーを書くなら sed より perl の方がいい - Qiita](https://qiita.com/takc923/items/8654d69008e921c9c9fb)

[【sed / awk / grep】文字列の置換・抽出・検索と正規表現 | Linux Cheat Sheet - Qiita](https://qiita.com/shuntaro_tamura/items/e4e942e7186934fae5e7)

[](https://blog.riywo.com/2011/04/19/022802/)

[Part 1: GNU Parallel script processing and execution - YouTube](https://www.youtube.com/watch?v=OpaiGYxkSuQ)

[すぐ忘れてしまう、仕事で使う技 - Qiita](https://qiita.com/hana_shin/items/53c3c78525c9c758ae7c)

[Bash、ターミナル関連の面白い URL まとめ(?) - Qiita](https://qiita.com/Cj-bc/items/08210305a888fcb829af)

<!--}}}-->

# 04/09/21<!--{{{-->

- [redis-cli コマンド操作まとめ - Qiita](https://qiita.com/rubytomato@github/items/d66d932959d596876ab5)
- [EVAL – Redis](https://redis.io/commands/eval)
- <https://evolany.larksuite.com/docs/docusJzCisQ6M6wJEmErDDjMBTd>

- [x] redis-cli command
- [x] redis basics
- [x] redis expire
- [x] redis-usecase
- [x] redis lua function
- [x] redis tastcase

- [ ] try docker osx image
- [ ] try textimg
<!--}}}-->

# 04/10/21 # 04/10/22<!--{{{-->

- [x] closed mapping in vim.
- [x] closed filetype indent in vim.
- [x] map noh highlighting.
- [x] vim-anynight collect colors.
- [x] collect learn english phrase to documents.
- [x] session box github account switching.
- [x] hyperapp initialized to kis9a/kis9a.
- [x] bash boxes snippets -> -d stone -p a8v8
- [x] vim - how to snippets. -> coc-snippets
- [x] select slide tool. -> bash-slides.
- [x] buy ipad 11 pro screen paper like film
- [x] memos2json rewrite with golang and sepalate index content json.
- [x] map nvim toggle term lua <https://github.com/akinsho/nvim-toggleterm.lua>
- [ ] try hyperapp tutorial.
<!--}}}-->

## 2021-04-12<!--{{{-->

- [x] new entry and controllers/redis functions test
- [x] search gmail response with compare controllers/email get_code.
- [x] build development environment anybot-lua.
- [x] lua complex object to redis cache, what kind of cache and how.
<!--}}}-->

## 2021-04-13<!--{{{-->

- [x] get threads length by mysql query.
- [x] imac setup account check. > ../../memos/accounts.md
- [x] imac setup development environment setup.
- [x] vimium customize styles and colors.
- [x] hyperapp index search in kis9a/memos with state.
- [x] update kis9a/ and dotfiles/
<!--}}}-->

## 2021-04-14<!--{{{-->

- get_threads api

  - [x] Redis 1 : $bid:threads: jsonstring
  - [x] Redis 2 : $tid:threads: jsonstring
  - [x] get thread list length for pagenation
  - [x] if empty cache get by db, else get by redis
  - [x] get tables rows_length when bid is arg_bid.
  - [x] get bot.assignment by cid=thread_id.

- [ ] Q: where get assignment to each threads ?
- [ ] Q: how to confirm the threadlist change ?
- [ ] Q: how long keepalive time redis cache ?
<!--}}}-->

# 2021-04-16<!--{{{-->

- [x] how to merge https://affinity.help/
- [x] make calm background with kis9a icon for imac.
<!--}}}-->

## Box<!--{{{-->

- [ ] add memorizing to kis9a.github.io/kis9a.
- [ ] hard to vimscript<https://learnvimscriptthehardway.stevelosh.com/>
- [ ] add articles to zenn.
- [ ] anynight lp scheme.
- [ ] anynight vim color scheme.
- [ ] invite keito to anynight.
- [ ] hyperapp code reading - what, how to vdom.
- [ ] hyperapp code reading - what, how to interface.
- [ ] static analysis collect sources. pup markdown2\*...

- [ ] script lolstr figlet -f --- | boxes -d stone -p a8v8(row,height) | lolcat & sleep and tput clear
- [ ] study how to slide with bash script.
<!--}}}-->


hacker
<https://kyne.com.au/~mark/software/>
<https://nmap.org/book/install.html>
<https://github.com/ShellShoccar-jpn>
<https://github.com/ShellShoccar-jpn/blog/blob/master/20161221_mappingly_programming.md>
<https://github.com/usp-engineers-community/Open-usp-Tukubai>
<https://qiita.com/suin/items/22662f43b6a6e8728798>
<https://github.com/unokun/go-todo-api>


bid:email:threads

```
-- Gmail object + Variables for authorization
local gmail = {
    client_id = '456471857910-b991s6erqcl8fpf6l2plv1gpss02alqa.apps.googleusercontent.com',
    client_secret = 'HVISFc3fWUn4LPtmOUBmUhWF',
    redirect_uri = 'http://localhost:8000/emails/gmail_get_tokens'
}

-- Gets msg contents
gmail.get_msg_contents = function(msg)
	-- Message data is broken up into parts with different types (html, plaintext, images)
	local contents = {}
	if not msg.payload.parts then
		table.insert(contents, msg.payload.body.data)
	else 
		local parts = A(msg.payload.parts)
		while #parts > 0 do
			local part = parts[1] -- First part may be an array of parts, or may contain data.
			table.remove(parts, 1)
			-- If part is an array of parts, concatenates part with parts, so it can later be checked for data.
			if part.parts ~= nil then
				parts = parts + A(part.parts)
			end

			if part.mimeType == 'text/plain' then
				table.insert(contents, part.body.data)
				-- contents = {mime_type = 'text/plain', data = gmail.base64_decode(part.body.data)}
			end
		end
	end
	
	for i=1,#contents do
		contents[i] = urlsafeb64_decode(contents[i])
	end
	-- TODO: get message attachments
	return A(contents):join('')
end




-- gmail.get_msg_contents = function() 
-- 	-- [essential function] - Gets contents of a message
-- 	local get_msg_contents = function(msg)
-- 		-- Message data is broken up into parts with different types (html, plaintext, images)
-- 		-- This function extracts and stores the base64 message data
-- 		local msg_data = {}
-- 		if not msg.payload.parts then
-- 			table.insert(msg_data, {
-- 				mime_type = msg.payload.mimeType,
-- 				data = msg.payload.body.data
-- 			})
-- 			return msg_data
-- 		end

-- 		local parts = A(msg.payload.parts)
-- 		while #parts > 0 do
-- 			local part = parts[1] -- First part may be an array of parts, or may contain data.
-- 			table.remove(parts, 1)
-- 			-- If part is an array of parts, concatenates part with parts, so it can later be checked for data.
-- 			if part.parts ~= nil then parts = parts + A(part.parts) end

-- 			-- If part is a data type, extracts the useful data.
-- 			if part.mimeType == 'text/plain' then return part.body.data end
-- 			-- THIS PART GETS THE IMAGE ATTACHMENTS
-- 			if part.mimeType == 'image/png' or part.mimeType == 'image/jpeg' then
-- 			    table.insert(msg_data, {
-- 			        mime_type = part.mimeType,
-- 			        attachment_id = part.body.attachmentId,
-- 			        file_name = part.filemail
-- 			    })
-- 			end
-- 		end
-- 		return msg_data
-- 	end
-- end




-- V2 FUNCTION: Gets a message data and returns format msg
gmail.format_msg = function(msg, bid)
	local hs = A(msg.payload.headers):tohash('name', 'value') -- Message headers in hash table format
    f_name, f_email = string.match(hs['From'], "(.+) <(.+)>")
	t_name, t_email = string.match(hs['To'], "(.+) <(.+)>")

	local formatted =  {
		bid = bid,
		message_id 	= msg.id,
		thread_id 	= msg.threadId,
		history_id  = "TEST",
		from_name 	= f_name,
		from_email 	= f_email,
		to_name 	= t_name,
		to_email 	= t_email,
        cc 			= hs['Cc'],
        subject 	= hs['Subject'], -- TODO: Add first message subject to the thread subject field
        content 	= gmail.get_msg_contents(msg),
		-- sent_date 	= strtotime(hs['Date']:gsub('+%d{4}', '')), -- TODO: Fix date after it got broken
		draft 		= 0,
		sent_f 		= 0,
		recent_f 	= 0,
		flagged_f 	= 0,
		important_f = A(msg.labelIds):has("IMPORTANT") and 1 or 0,
		answered_f 	= 0,
		trashed_f 	= 0,
		read_f 		= not A(msg.labelIds):has("UNREAD") and 1 or 0,
	}
	return formatted
end

-- Fetch the Gmail Access Token and refresh token (FIRST TIME ONLY)
gmail.get_refresh_token = function(args)
	elog('Fetching tokens from google...')

	local bid = 10 -- bot id - testing
	local mid = 3 -- member id - testing

    local body = {
        code 			= args.code,
        client_id 		= gmail.client_id,
        client_secret 	= gmail.client_secret,
        grant_type 		= 'authorization_code', -- removed redirect uri.. ok?
        access_type 	= 'offline'
    }
    -- Returns JSON data containing refresh_token, access_token
    local token_data = json_decode(call('https://oauth2.googleapis.com/token', 'POST', body))

    local creds_formatted = {
        bid 			= bid,
        mid 			= mid,
        access_token 	= token_data.access_token,
        expires_in 		= token_data.expires_in,
		refresh_token 	= token_data.refresh_token,
        last_refresh_t 	= time(),
    }

	db_migrate('google_creds', 'google_creds')
	local conn = db_conn('google_creds')
	local res, err, code, stat = db_save('google_creds@google_creds', creds_formatted, true, conn)

end

-- Uses the EXISTING refresh token to refresh the (expired or almost expired) access token
gmail.refresh_access_token = function(creds)
	elog("Refreshing access token...")
    local body = {
        refresh_token 	= creds.refresh_token,
        client_id 		= gmail.client_id,
        client_secret 	= gmail.client_secret,
        redirect_uri 	= gmail.redirect_uri, -- TODO: PLEASE DOUBLE CHECK THE REDIRECT URI HERE
        grant_type 		= 'refresh_token',
        access_type 	= 'offline'
    }
    local t_data = json_decode(call('https://oauth2.googleapis.com/token', 'POST', body))
    local formatted_creds = {
        id 				= creds.id,
        access_token 	= t_data.access_token,
        expires_in 		= t_data.expires_in,
        last_refresh_t 	= time(),
		last_active_t   = time()
    }
    db_save('google_creds', formatted_creds)
    return t_data.access_token
end

-- Gets list of thread ids and snippets
gmail.list_threads = function(creds)
	elog("Getting list of threads...")
	local tbl = S('email_threads_', creds.bid)

	local conn = db_conn('email_threads')

	-- Threads stored in database
	local db_ts = db_query("email_threads", S("SELECT thread_id, history_id FROM ", tbl))
	local t_ids = {}
	for i=1, #db_ts do
		-- Save thread id as the key, and history id as value
		if db_ts[i] ~= nil then t_ids[db_ts[i].thread_id] = db_ts[i].history_id end
	end

	-- Fetch threads from google
	local uri = 'https://gmail.googleapis.com/gmail/v1/users/me/threads'
	local hdrs = {Authorization = S('Bearer ', creds.access_token)}
	local threads = json_decode(call(uri, 'GET', '', hdrs))
	-- TODO: Find out why threads sometimes dont check at all
	elog("Thread check", threads)

	if empty(threads) then
		elog("No Threads")
		return
	end

-- 	-- returns all threads which are new or have been changed
-- 		-- {{thread_id1 = history_id}, {thread_id2 = history_id}}
-- 	 local is_changed_threads = not empty(A(threads):map(function(t)
-- 		if t_ids[t.id] == nil or t_ids[t.id] ~= t.historyId then
-- 			return { history_id=t.historyId, thread_id=t.id, bid=creds.bid, snippet=t.snippet, subject=t.subject } -- return thread which is either new, or has been changed
-- 		end
-- 	end))

	return threads
end

-- Takes the msgs from a single Thread and imports them to DB.
gmail.gmail_get_thread_msgs = function(creds)
	elog("THESE ARE CREDS", creds)
	-- fetch timing
	--[[
		1. redis doesnt have email cached. redis expires within (a day)
		2. the bot/ email is in use ( logged in within --days ago )
	]]

	-- if current time is past the time that the access_token expires in (ie token is expired)
	local now = time() - 600
	local expire_t = creds.last_refresh_t + creds.expires_in
	if now > expire_t then
		creds.access_token = gmail.refresh_access_token(creds) -- get new access token if expired
	end

	local new_threads  = gmail.list_threads(creds)
	if new_threads == nil then return "No threads to fetch" end

	local is_update = gmail.is_update_thread(creds.bid, creds.mailing_lists)

	if is_update then
		elog("is update - can excute --------------", type(new_threads))
		-- empty array to put new messages into
		local new_msgs = {}
		local h = {Authorization = S('Bearer ', creds.access_token)}

		local ids = db_query("email_msgs", S("SELECT message_id FROM email_msgs_", creds.bid))
		local msg_ids = {}
		for i=1, #ids do
			if ids[i] ~= nil then  msg_ids[ids[i].message_id] = i end
		end

		-- elog(ids)

		A(new_threads):each(function(t)
			elog("new_threads - this is excuteing --------------" )
			local uri = S('https://gmail.googleapis.com/gmail/v1/users/me/threads/', t.thread_id)
			local msgs = json_decode(call(uri, 'GET', '', h)).messages

			if msgs == nil then return end
			gmail.update_redis_cache(creds.id, creds.email)
			-- Filters out msgs which are already in the DB
			msgs = A(msgs):map(function(msg) if msg_ids[msg.id] == nil then return msg end end)
			if empty(msgs) then return end

			-- Put all sender names into array in thread table
			local names = {} -- array of sender names to put in the thread
			local old_names = json_decode(t.names) or {}
			-- Formats the messages
			local fmt_msgs = A(msgs):map(function(msg)
				local fmt_msg =  gmail.format_msg(msg, creds.bid)
				table.insert(names, fmt_msg.from_name)
				return fmt_msg
			end)
			for _,v in ipairs(names) do table.insert(old_names, v) end
			t.names = json_encode(old_names)
			
			-- Move new msgs into new_msgs
			for i=1, #fmt_msgs do
				table.insert(new_msgs, fmt_msgs[i])
			end
		end)
		if empty(new_msgs) then return end

		db_migrate('email_msgs', S('email_msgs_', creds.bid))
		db_import(S('email_threads_', creds.bid, '@email_threads'), new_threads, db_conn('email_threads'))

		-- table of threads - Split up new_msgs for db_import time constraint
		local tts = {}
		local cnt = 0
		for i=1, #new_msgs do
			if i % 10 == 1 then cnt = cnt + 1 end
			tts[cnt] = tts[cnt] or {}
			if new_msgs[i].content then A(tts[cnt]):push(new_msgs[i]) end
		end

		-- Cleans up msgs array
		tts = A(tts):filter(function (t) if not empty(t) then return t end end)
		for i=1, #tts do
			db_import(S('email_msgs_', creds.bid, '@email_msgs'), tts[i], db_conn('email_msgs'))
		end
	end
end

--[[
	TODO:
	1 Add gid(google creds column) in email_threads table
	2 Add gid (google cred col) in email_msgs table
	3 Add last_active time to google_creds table
]]--

gmail.batch_fetch = function()
	local creds_list = db_find('google_creds', {['last_use_t@gt']=time()-86400}) -- google creds which have been active in the past day

	-- local wc = ngx.worker.count()
	-- local wi = ngx.worker.id() -- Related to multi-threading with multi workers


	local is_update = gmail.is_update_thread(creds.bid, creds.email)

	-- is_update
	  -- expected:
	  -- update redis_cache and db_thread

	-- for i = 1, #creds_list do
	-- 	local creds = creds_list[i]
	-- 	is_update 
	-- 	if is_update then 
	-- 	   update redis cache from db
	-- 	end
	-- 	local new_threads_list = gmail.list_threads(creds)

	-- 	if new_threads_list then
	-- 		gmail.gmail_get_thread_msgs(new_threads_list, creds)
	-- 		else
	-- 		local rc = redis_conn("email")
	-- 		-- rc:get("bid":"email":"threads")
	-- 		-- return redis_cache
	-- 	end
	-- 	-- gmail.gmail_get_thread_msgs(cred)
	-- end
end



--[[
	1 - get all creds which have been updated in the past day (all active google creds) --> Or ones which have been... active, not updated, since upd_t will be self-perpetuating
	How do we check for activity status??
	2 - get all bids and emails from the google creds
	3 - for each bid, update the threads for all mail boxes related to that bid.
	4 - split up the difficult processes with ngx workers
--]]

gmail.is_update_thread = function(bid, email)
	if empty(bid) or empty(email) then return end
	email = "cs@evolany.com"
	local rc = redis_conn("email")
	local rcv = rc:get(S(bid,':', email, ':', 'threads'))
	if rcv == ngx.null then return true end
	local last_thread = db_query("email_threads", S("select history_id from email_threads_", bid, " order by upd_t limit 1"))
	local last_hid = last_thread and last_thread[1]["history_id"]
	local rcv_hid = not empty(last_thread) and rcv["hid"]
	return last_hid ~= rcv_hid and true or false
end

gmail.update_redis_cache = function(bid, email, limit)
	local rs = {}
	local ttb_info = db_query('email_threads', S("select count(*) as total from email_threads_", bid)) -- thread table
	local ttb_total = ttb_info[1]["total"]
	local ttb = db_query("email_threads", S( "select * from email_threads_", bid, " limit ", limit or 20))

	for _, t in ipairs(ttb) do
		local assignments = db_query("assignments", S( 'select assignee_id, name from assignment where cid="', t["thread_id"],'"'))
		if not empty(assignments) then
			t["assignments"] = assignments
		end
	end

	rs["total"] = ttb_total
	rs["data"] = ttb

	local rc = redis_conn("email")
	rc:set(S(bid, ":" .. email .. ":" .. ":threads"), json_encode(rs))
	rc:set_keepalive(864000000)
	return rs
end


return gmail
```

```
local gm = require("gmail")

local controller = {
	test_get = function ()

-- 		local a = true

-- 		if a then
-- 			elog(a, "teuuuuuuuuuuuuuuuu")
-- 		end
		-- local apple = gm.is_update_thread(10, "{'cs@evolany.com':'Label_3164331883390088941'}")
		-- elog("apple -----------------------------------------------------------", apple)
		-- bid = "1"
		-- if empty(bid) or empty(ename) then return end
		-- elog("bid---------------------------------------------------bid")
		-- local res = gm.gmail_get_thread_msgs()
		--
		elog(gm.client_id)
		gm.update_redis_cache(10, "cs@evolany.com", 21)
	end,
	-- Redirects user to google Oauth login, fetches their auth code
	gmail_get_creds = function(params)
		elog("Getting gmail credentials...")
		local uri_json = json_encode({uri = 'http://localhost:8000/emails/test_haya'})
		local params_uri = base64_encode(uri_json)
		return redirect(
			S('https://accounts.google.com/o/oauth2/auth?',
			'response_type=code',
			'&redirect_uri=', gm.redirect_uri,
			'&client_id=', gm.client_id,
			'&state=', params_uri,
			'&scope=https://www.googleapis.com/auth/gmail.readonly',
			'&access_type=offline',
			'&nonce=0394852-3190485-2490358')) -- todo - what is nonce for? what about mailing list too btw?
	end,
	
    -- Fetches refresh_token from google API using auth_code (contained in args)
    gmail_get_tokens = function(args)
		elog("Getting gmail tokens...")
		elog("THE ARGS.state ..", args.state)
		local state_json = base64_decode(args.state)
		local state = json_decode(state_json)
		elog("THIS is the state", state)
        gm.get_refresh_token(args) 
    end,


  	get_threads = function(q)
      	local bid, email = check_params(q, 'bid', 'email')
	  	local limit = tonumber(q["limit"]) or 20
		-- local upc = q["upc"] == "true" or false

      	local rc = redis_conn("email")
      	local rcv = rc:get(bid .. ":threads")

	  	local is_diffirent_limit = function()
			local rcvtb = json_decode(rcv)
			return (#rcvtb["data"] ~= limit);
	  	end

		if empty(rcv) or rcv and is_diffirent_limit() then
          	elog('return from db -----------------------------')
			-- local rs = get_bot_threads(bid)
			local rs = gm.update_redis_cache(bid, email)
			dump(rs)
		else
          	elog('return from redis cache -------------------------')
			dump(rcv)
		end
		-- local get_bot_threads = function (bid)
		-- 	gm.update_redis_cache(bid, ename)
			-- local rs = {}
          	-- local ttb_info = db_query('email_threads',
          	                          -- S("select count(*) as total from email_threads_", bid)) -- thread table
          	-- local ttb_total = ttb_info[1]["total"]
          	-- local ttb = db_query("email_threads", S( "select * from email_threads_", bid, " limit ", limit))

          	-- -- todo: reduce sql actions
          	-- for _, t in ipairs(ttb) do
          	    -- local assignments = db_query("assignments", S(
          	                                      -- "select assignee_id, name from assignment where cid=",
          	                                      -- t["id"]))
          	    -- if not empty(assignments) then
          	        -- t["assignments"] = assignments
          	    -- end
          	-- end

          	-- rs["total"] = ttb_total
          	-- rs["data"] = ttb

          	-- rc:set(bid .. ":threads", json_encode(rs))
			-- return rs
		-- end

-- 		if (upc) then
-- 			local rs = {}
-- 			local tbns = db_query('email_threads', "select table_name from information_schema.tables where table_schema = database() and table_name like 'email_threads_%'")
-- 			for _, tbn in ipairs(tbns) do
-- 				local num = string.match(tbn["table_name"], "%d+")
-- 				table.concat(rs, to_str(get_bot_threads(num)))
-- 			end
-- 			dump(rs)
--           	elog('update thread caches each bots -----------------------------')
-- 		end
 	end,

  	get_messages = function(q)
      	local tid,bid = check_params(q, 'tid', 'bid')
      	local rc = redis_conn("email")
      	local rcv = rc:get(tid .. ":messages")

      	if empty(rcv) then
          	local mtb = db_query('email_msgs', S("SELECT * from email_msgs_", bid, " where thread_id='", tid, "'")) -- msg table
          	rc:set(tid .. ":messages", json_encode(mtb))
          	elog('return from db -----------------------------')
          	dump(mtb)
      	else
          	elog('return from redis cache -------------------------')
          	dump(rcv)
      	end
  	end,
  
	keyword_query = function(q) 
		
		local bid = check_params(q, 'bid')
		local st = q['search_term']
		local searchQuery = {}
		if st then 
			st = (st):split(" ") or {}
			for i = 1, #st do
				local q= ' where '
				if i > 1 then q = 'or ' end
				searchQuery[i] = S(q,'from_name like "%',st[i], '%" or from_email like "%', st[i], '%" or to_name like "%', st[i],'%" or to_email like "%', st[i], '%" or cc like "%', st[i], '%" or subject like "%', st[i], '%" or content like "%', st[i], '%"')
			end
		end
		searchQuery = table.concat(searchQuery,"")
	
		-- local threads = db_query('email_threads', S('select t.*, b.assignee_id, b.name from emails.email_threads_',bid,' t left join bots.assignment b on t.id = b.cid where thread_id in (select distinct thread_id from email_msgs_',bid, searchQuery, ')'))
		local threads = db_query('email_threads', S('select * from email_threads_',bid,' where thread_id in (select distinct thread_id from email_msgs_',bid, searchQuery, ')'))
		local threadsLength = #threads

		-- get assignments for thread
		for i = 1, threadsLength do
			local assignments = db_query("assignments", S('select assignee_id, name from assignment where cid=',threads[i]['id']))
          	    if not empty(assignments) then
          	        threads[i]["assignments"] = assignments
          	    end
		end
	end,

	update_tags = function(q,data)
		local bid = data.bid 
		local t = data.tags
		local tid = data.thread_id
		db_query('email_threads', S('update email_threads_',bid,' set tag = "', t, '" where thread_id = "', tid, '"'))
	end,
}

dispatch(controller)
```
